---
sidebar_position: 1
pagination_next: reference/slices-segments
---

# Layers

Layers are the first level of organisational hierarchy in Feature-Sliced Design. Their purpose is to separate code based on how much responsibility it needs and how many other modules in the app it depends on.

Every layer carries special semantic meaning to help you determine how much responsibility you should allocate to your code. The names and meanings of layers are standardized across all projects built with Feature-Sliced Design.

There are **7 layers** in total, arranged from most responsibility and&nbsp;dependency to least:

<img src="/img/layers/folders-graphic-light.svg#light-mode-only" width="180" style={{ float: "right", margin: "0 1em" }} alt="A file system tree, with a single root folder called src and then seven subfolders: app, processes, pages, widgets, features, entities, shared. The processes folder is slightly faded out." />
<img src="/img/layers/folders-graphic-dark.svg#dark-mode-only" width="180" style={{ float: "right", margin: "0 1em" }} alt="A file system tree, with a single root folder called src and then seven subfolders: app, processes, pages, widgets, features, entities, shared. The processes folder is slightly faded out." />

1. App
2. Processes (deprecated)
3. Pages
4. Widgets
5. Features
6. Entities
7. Shared

You don't have to use every layer in your project ‚Äî only add them if you think it brings value to your project. Typically, most frontend projects will have at least the Shared, Pages, and App layers.

## Import rule on layers

:::note

On this page, a _module_ refers to an internal module in the application ‚Äî a file or directory with an index file. Not to be confused with npm packages.

:::

Layers are made up of _slices_ ‚Äî highly cohesive groups of modules. Feature-Sliced Design promotes low coupling, which is why dependencies between slices are regulated by **the import rule on layers**:

> _A module in a slice can only import other slices when they are located on layers strictly below._

For example, in `~/features/aaa`, `aaa` is the slice, so a file `~/features/aaa/api/request.ts` cannot import code from any module in `~/features/bbb`, but can import code from `~/entities` and `~/shared`, as well as any sibling code from `~/features/aaa`.

Layers App and Shared are **exceptions** ‚Äî they are simultaneously a layer and a slice. This is because slices partition code by business domain, and for Shared, there are no business domains, and the App layer combines all business domains. In practice, this means that layers App and Shared are made up of segments, and segments can import each other freely.

## Layer definitions

This section describes the semantic meaning of each layer to create an intuition for what kind of code belongs there.

### Shared

This layer forms a foundation for the rest of the app. It's a place to create connections with the external world, for example, backends, third-party libraries, the environment. It is also a place to define your own highly contained libraries.

This layer, like the App layer, _does not contain slices_. Slices are intended to divide the layer into business domains, but business domains do not exist in Shared. This means that segments can reference and import from each other.

Here are the segments that you can typically find in this layer:

- `üìÅ api` ‚Äî the API client and potentially also functions to make requests to specific backend endpoints.
- `üìÅ ui` ‚Äî the application's UI kit.  
  Components on this layer should not contain business logic, but it's okay for them to be business-themed. For example, you can put the company logo and page layout here.
- `üìÅ lib` ‚Äî a collection of libraries (they can literally be packages, but don't have to).  
  This folder should not be treated as helpers or utilities ([read here why these folders often turn into a dump][ext--sova-utility-dump]). Instead, every library in this folder should have one area of focus, for example, dates, colors, text manipulation, etc. That area of focus should be documented in a README file. The developers in your team should know what can and cannot be added to these libraries.
- `üìÅ config` ‚Äî environment variables, global feature flags and other global configuration for your app.
- `üìÅ routes` ‚Äî route constants or patterns for matching routes.
- `üìÅ i18n` ‚Äî setup code for translations, global translation strings.

You are free to add more segments, but make sure that the name of these segments describes the purpose of the content, not its essence. For example, `components`, `hooks`, and `types` are bad segment names because they aren't that helpful when you're looking for code.

### Entities

Slices on this layer represent concepts from the real world that the project is working with. Commonly, they are the terms that the business uses to describe the product. For example, a social network might work with business entities like User, Post, and Group.

An entity slice might contain the data storage (`üìÅ model`), data validation schemas (`üìÅ model`), entity-related API request functions (`üìÅ api`), as well as the visual representation of this entity in the interface (`üìÅ ui`). The visual representation doesn't have to produce a complete UI block ‚Äî it is primarily meant to reuse the same appearance across several pages in the app, and different business logic may be attached to it through props or slots.

#### Entity relationships

Entities in FSD are slices, and by default, slices cannot know about each other. In real life, however, entities often interact with each other, and sometimes one entity owns or contains other entities. Because of that, the business logic of these interactions is best kept in higher layers, like Features or Pages. 

When one entity's data object contains other data objects, usually it's a good idea to make the connection between the entities explicit and side-step the slice isolation by making a cross-reference API with the `@x` notation. The reason is that connected entities need to be refactored together, so it's best to make the connection impossible to miss.

TODO: Add a link to the cross-reference API documentation.

### Features

Actions that a user can make in the application to interact with the business entities to achieve a valuable outcome. This also includes actions that the app makes on behalf of the user to produce value for them.

Slices in this layer typically contain _interactive_ UI elements, internal state, and optionally, API calls that enable value-producing actions.

**Slice examples**:

<table>
<thead><tr><th> For a social network </th><th> For a Git frontend (e.g., GitHub) </th><th> Actions on behalf of users </th></tr></thead>
<tbody><tr><td><ul>
<li>Authenticate</li>
<li>Create a post</li>
<li>Join a group</li>
</ul></td><td><ul>
<li>Edit a file</li>
<li>Leave a comment</li>
<li>Merge branches</li>
</ul></td><td><ul>
<li>Detect dark mode</li>
<li>Perform background computation</li>
<li>User-Agent-based actions</li>
</ul></td></tr></tbody></table>

### Widgets

Self-sufficient UI blocks that emerged from the composition of lower-level units like entities and features.

This layer provides a way to fill in the slots left in the UI of Entities with other Entities and interactive elements from Features. Therefore, it is common not to have business logic on this layer, instead keeping it in Features. Each slice in this layer contains ready-to-use UI components and sometimes non-business logic such as gestures, keyboard interaction, etc.

Sometimes, however, it is more convenient to have business logic on this layer. Usually it happens when the widget is quite rich in interactivity (e.g., interactive data tables) and the business logic inside them is not used in other places.

**Slice examples**:

<table>
<thead><tr><th> For a social network </th><th> For a Git frontend (e.g., GitHub) </th></tr></thead>
<tbody><tr><td><ul>
<li>Post card</li>
<li>User profile header (with actions)</li>
</ul></td><td><ul>
<li>List of files in a repository (with actions)</li>
<li>Comment in a thread</li>
<li>Repository card</li>
</ul></td></tr></tbody></table>

:::tip

If you're using a nested routing system (e.g. the router of [Remix][ext--remix]), it may be helpful to use the Widgets layer in the same way as a flat routing system would use the Pages layer ‚Äî to create complete interface blocks, complete with related data fetching, loading states, and error boundaries. In the same way, you can store page layouts on this layer.

:::

### Pages

Complete pages for a page-based application (like a website) or screens/activities for screen-based applications (like mobile apps).

This layer is similar to Widgets in its compositional nature, albeit on a larger scale. Each slice in this layer contains UI components that are ready to be plugged into a router and sometimes data-fetching logic and error handling.

**Slice examples**:

<table>
<thead><tr><th> For a social network </th><th> For a Git frontend (e.g., GitHub) </th></tr></thead>
<tbody><tr><td><ul>
<li>News feed</li>
<li>Community page</li>
<li>User's public profile</li>
</ul></td><td><ul>
<li>Repository page</li>
<li>User's repositories</li>
<li>Branches in a repository</li>
</ul></td></tr></tbody></table>

### Processes

:::caution

This layer has been deprecated. The current version of the spec recommends avoiding it and moving its contents to `features` and `app` instead.

:::

Escape hatches for multi-page interactions.

This layer is deliberately left undefined. Most applications should not use this layer, and keep router-level and server-level logic on the App layer. Consider using this layer only when the App layer grows large enough to become unmaintainable and needs unloading.

### App

All kinds of app-wide matters, both in the technical sense (e.g., context providers) and in the business sense (e.g., analytics).

This layer usually doesn't contain slices, like Shared, instead having segments directly.

**Content examples**:

* Styles
* Routing
* Store and other context providers
* Analytics initialization

[ext--remix]: https://remix.run
[ext--sova-utility-dump]: https://dev.to/sergeysova/why-utils-helpers-is-a-dump-45fo
